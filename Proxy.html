<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Proxy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      /* Default theme (Purple) */
      --bg-primary: #000;
      --bg-secondary: #1a001a;
      --bg-tertiary: #2a0033;
      --bg-quaternary: #3a0044;
      --bg-accent: #4a0055;
      --text-primary: #d0f;
      --text-secondary: #d0f9;
      --border-primary: #d0f;
      --border-secondary: rgba(221, 0, 255, 0.3);
      --border-tertiary: #d0f3;
      --accent-primary: #ff00ff;
      --accent-secondary: #d0f;
      --shadow-primary: rgba(221, 0, 255, 0.5);
      --shadow-secondary: rgba(221, 0, 255, 0.3);
      --shadow-tertiary: rgba(221, 0, 255, 0.2);
      --error-color: #f00;
      --warning-color: #ff0;
      --info-color: #0ff;
      --success-color: #0f0;
      --transition-speed: 0.3s;
    }

    * {
      box-sizing: border-box;
      transition: background-color var(--transition-speed) ease,
        color var(--transition-speed) ease, border-color var(--transition-speed) ease,
        box-shadow var(--transition-speed) ease;
    }

    body {
      margin: 0;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    /* Loading animation */
    @keyframes pulse {
      0% {
        opacity: 0.6;
      }

      50% {
        opacity: 1;
      }

      100% {
        opacity: 0.6;
      }
    }

    @keyframes slideInFromTop {
      from {
        transform: translateY(-100%);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes glow {
      0% {
        box-shadow: 0 0 5px var(--accent-secondary);
      }

      50% {
        box-shadow: 0 0 20px var(--accent-secondary);
      }

      100% {
        box-shadow: 0 0 5px var(--accent-secondary);
      }
    }

    #controls {
      padding: 0.5rem 1rem;
      background: var(--bg-secondary);
      display: flex;
      gap: 0.75rem;
      align-items: center;
      animation: slideInFromTop 0.3s ease-out;
    }

    input {
      flex: 1;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 1rem;
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--border-primary);
      border-radius: 4px;
    }

    input:focus {
      outline: none;
      box-shadow: 0 0 10px var(--shadow-primary);
      border-color: var(--accent-primary);
    }

    input::placeholder {
      color: var(--text-secondary);
    }

    button {
      background: rgba(0, 0, 0, 0);
      color: var(--text-primary);
      border: 1px solid rgba(0, 0, 0, 0);
      padding: 0.5rem 1rem;
      font-size: 1rem;
      border-radius: 4px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    button svg {
      width: 100%;
      height: 100%;
      max-width: 24px;
      max-height: 24px;
      object-fit: contain;
    }

    button:hover {
      background: var(--bg-accent);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px var(--shadow-secondary);
    }

    button:active {
      transform: scale(0.95);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    #tab-bar {
      display: flex;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-primary);
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--border-primary) var(--bg-secondary);
      animation: slideInFromTop 0.4s ease-out;
      scroll-behavior: smooth;
    }

    #tab-bar::-webkit-scrollbar {
      height: 5px;
    }

    #tab-bar::-webkit-scrollbar-thumb {
      background-color: var(--border-primary);
    }

    #tab-bar::-webkit-scrollbar-track {
      background-color: var(--bg-secondary);
    }

    .tab {
      padding: 0.5rem 1rem;
      background: var(--bg-tertiary);
      border: 1px solid rgba(0, 0, 0, 0);
      border-radius: 20% 20% 0% 0%;
      cursor: pointer;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      max-width: 200px;
      min-width: 100px;
      transform: translateY(0);
    }

    .tab.active {
      background: var(--bg-quaternary);
      border: 1px solid var(--border-secondary);
      transform: translateY(-2px);
      box-shadow: 0 2px 10px var(--shadow-secondary);
    }

    .tab:hover:not(.active) {
      background: var(--bg-accent);
      transform: translateY(-1px);
    }

    .tab-title {
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }

    .tab-close {
      font-size: 1.2rem;
      line-height: 1;
      padding: 0.2rem;
      border-radius: 50%;
    }

    .tab-close:hover {
      color: var(--text-primary);
      background: var(--bg-accent);
      transform: scale(1.1);
    }

    #new-tab {
      padding: 0.5rem 1rem;
      background: rgba(42, 0, 51, 0);
      cursor: pointer;
      font-size: 1.2rem;
      border-radius: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
    }

    #new-tab:hover {
      background: var(--bg-tertiary);
      transform: scale(1.1);
      animation: glow 2s infinite;
    }

    #content {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }

    .iframe-container {
      flex: 1;
      display: none;
      opacity: 0;
    }

    .iframe-container.active {
      display: block;
      opacity: 1;
    }

    .iframe-container.loading {
      opacity: 0.7;
    }

    iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: var(--bg-primary);
    }

    #iframe-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      animation: fadeIn 0.3s ease-out;
      z-index: 10;
    }

    #iframe-overlay p {
      max-width: 60%;
      margin-bottom: 1rem;
      color: var(--text-secondary);
    }

    #iframe-overlay-logo {
      width: 100px;
      height: 100px;
      margin-bottom: 1.5rem;
      animation: pulse 2s infinite;
      color: var(--accent-primary);
    }

    #loading-indicator {
      display: none;
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      background: var(--bg-accent);
      color: var(--text-primary);
      padding: 0.5rem 1rem;
      border-radius: 4px;
      box-shadow: 0 4px 10px var(--shadow-tertiary);
      animation: fadeIn 0.3s ease-out;
      z-index: 20;
    }

    .loading-text::after {
      content: '...';
      animation: pulse 1s infinite;
    }
  </style>
</head>

<body>
  <div id="controls">
    <button id="back-button" disabled>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M19 12H5M12 19l-7-7 7-7" />
      </svg>
    </button>
    <button id="forward-button" disabled>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M5 12h14M12 5l7 7-7 7" />
      </svg>
    </button>
    <form id="proxy-form" style="display: contents;">
      <input type="url" id="target-url" placeholder="Enter URL or search..." required />
      <button type="submit" id="go-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M5 12h14M12 5l7 7-7 7" />
        </svg>
      </button>
    </form>
  </div>
  <div id="tab-bar">
    <button id="new-tab">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="5" x2="12" y2="19" />
        <line x1="5" y1="12" x2="19" y2="12" />
      </svg>
    </button>
  </div>
  <div id="content">
    <div id="iframe-overlay">
      <svg id="iframe-overlay-logo" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 2L2 7l10 5 10-5-10-5z" />
        <path d="M2 17l10 5 10-5" />
        <path d="M2 12l10 5 10-5" />
      </svg>
      <h1>Proxy</h1>
      <p>A simple client-side web proxy using allOrigins.</p>
    </div>
  </div>
  <div id="loading-indicator">
    <span class="loading-text">Loading</span>
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const targetUrlInput = document.getElementById('target-url');
      const proxyForm = document.getElementById('proxy-form');
      const content = document.getElementById('content');
      const iframeOverlay = document.getElementById('iframe-overlay');
      const loadingIndicator = document.getElementById('loading-indicator');
      const tabBar = document.getElementById('tab-bar');
      const newTabButton = document.getElementById('new-tab');
      const backButton = document.getElementById('back-button');
      const forwardButton = document.getElementById('forward-button');

      let tabs = [];
      let activeTabIndex = -1;

      // Function to create and add a new tab and its content
      function addTab(url = '') {
        const tabId = `tab-${Date.now()}`;
        const tabElement = document.createElement('div');
        tabElement.className = 'tab';
        tabElement.dataset.tabId = tabId;
        tabElement.innerHTML = `
          <span class="tab-title">New Tab</span>
          <span class="tab-close">&times;</span>
        `;
        tabBar.insertBefore(tabElement, newTabButton);

        const iframeContainer = document.createElement('div');
        iframeContainer.className = 'iframe-container';
        iframeContainer.dataset.tabId = tabId;
        iframeContainer.innerHTML = `<iframe src="about:blank" sandbox="allow-same-origin allow-scripts allow-forms allow-pointer-lock allow-modals allow-orientation-lock allow-presentation"></iframe>`;
        content.appendChild(iframeContainer);

        const newTab = {
          id: tabId,
          url: url,
          iframeContainer: iframeContainer,
          tabElement: tabElement,
          history: []
        };

        tabs.push(newTab);
        activateTab(tabs.length - 1);

        if (url) {
          loadUrlInTab(newTab, url);
        } else {
          showOverlay(newTab);
        }

        tabElement.addEventListener('click', (e) => {
          if (!e.target.classList.contains('tab-close')) {
            const index = tabs.findIndex(t => t.id === tabId);
            if (index !== -1) {
              activateTab(index);
            }
          }
        });

        tabElement.querySelector('.tab-close').addEventListener('click', (e) => {
          e.stopPropagation();
          closeTab(tabId);
        });

        tabBar.scrollLeft = tabBar.scrollWidth;
      }

      // Function to activate a specific tab
      function activateTab(index) {
        if (activeTabIndex !== -1 && tabs[activeTabIndex]) {
          tabs[activeTabIndex].tabElement.classList.remove('active');
          tabs[activeTabIndex].iframeContainer.classList.remove('active');
        }

        activeTabIndex = index;
        if (activeTabIndex !== -1 && tabs[activeTabIndex]) {
          tabs[activeTabIndex].tabElement.classList.add('active');
          tabs[activeTabIndex].iframeContainer.classList.add('active');
          targetUrlInput.value = tabs[activeTabIndex].url;
          updateNavigationButtons();
          hideOverlay();
        } else {
          showOverlay();
        }
      }

      // Function to close a tab
      function closeTab(tabId) {
        const index = tabs.findIndex(t => t.id === tabId);
        if (index === -1) return;

        const tab = tabs[index];
        tab.tabElement.remove();
        tab.iframeContainer.remove();
        tabs.splice(index, 1);

        if (tabs.length === 0) {
          addTab();
        } else {
          const newActiveIndex = Math.min(index, tabs.length - 1);
          activateTab(newActiveIndex);
        }
      }

      // Centralized proxy service management
      class ProxyManager {
        constructor() {
          this.services = [
            {
              name: 'AllOrigins',
              url: 'https://api.allorigins.win/raw?url=',
              encode: true,
              healthy: true
            },
            {
              name: 'CorsAnywhere', 
              url: 'https://cors-anywhere.herokuapp.com/',
              encode: false,
              healthy: true
            },
            {
              name: 'CodeTabs',
              url: 'https://api.codetabs.com/v1/proxy?quest=',
              encode: true,
              healthy: true
            }
          ];
          this.currentServiceIndex = 0;
        }

        getProxiedUrl(targetUrl, baseUrl = null) {
          try {
            const absoluteUrl = baseUrl ? new URL(targetUrl, baseUrl).href : new URL(targetUrl).href;
            const service = this.services[this.currentServiceIndex];
            
            if (service.encode) {
              return service.url + encodeURIComponent(absoluteUrl);
            } else {
              return service.url + absoluteUrl;
            }
          } catch (e) {
            console.warn(`Could not create proxied URL for: ${targetUrl}`, e);
            return targetUrl;
          }
        }

        async fetchThroughProxy(url, options = {}) {
          let lastError = null;

          for (let i = 0; i < this.services.length; i++) {
            const serviceIndex = (this.currentServiceIndex + i) % this.services.length;
            const service = this.services[serviceIndex];
            
            if (!service.healthy) continue;

            try {
              const proxyUrl = service.encode ? 
                service.url + encodeURIComponent(url) : 
                service.url + url;
              
              const response = await fetch(proxyUrl, options);
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              
              this.currentServiceIndex = serviceIndex;
              return response;
            } catch (error) {
              console.warn(`Proxy service ${service.name} failed:`, error);
              service.healthy = false;
              setTimeout(() => { service.healthy = true; }, 30000); // Re-enable after 30s
              lastError = error;
              continue;
            }
          }

          throw lastError || new Error('All proxy services failed');
        }

        isAlreadyProxied(url) {
          return this.services.some(service => url.includes(service.url.split('?')[0]));
        }
      }

      const proxyManager = new ProxyManager();

      // Function to load a URL into a specific tab
      async function loadUrlInTab(tab, url) {
        const normalizedUrl = normalizeUrl(url);
        if (!normalizedUrl) {
          displayError(tab, 'Invalid URL or search query.');
          return;
        }

        const iframe = tab.iframeContainer.querySelector('iframe');
        const originalUrl = normalizedUrl;

        tab.url = originalUrl;
        targetUrlInput.value = originalUrl;
        tab.iframeContainer.classList.add('loading');
        loadingIndicator.style.display = 'block';

        const historyIndex = tab.history.indexOf(originalUrl);
        if (historyIndex > -1) {
          tab.history.splice(historyIndex + 1);
        } else {
          tab.history.push(originalUrl);
        }
        updateNavigationButtons();
        updateTabTitle(tab, 'Loading...');

        try {
          const response = await proxyManager.fetchThroughProxy(normalizedUrl);
          const htmlContent = await response.text();

          const parser = new DOMParser();
          const doc = parser.parseFromString(htmlContent, 'text/html');
          
          // Comprehensive URL rewriting for recursive proxy
          await rewriteUrls(doc, originalUrl);

          // Add base tag for proper URL resolution
          const baseTag = doc.createElement('base');
          baseTag.href = originalUrl;
          if (doc.head) {
            doc.head.insertBefore(baseTag, doc.head.firstChild);
          }

          // Enhanced script injection optimized for games
          const newScript = doc.createElement('script');
          newScript.textContent = `
            // Store original base URL for relative URL resolution
            window.PROXY_BASE_URL = "${originalUrl}";
            
            // Non-intrusive proxy URL generation
            function getProxiedUrl(url) {
              // Don't proxy blob, data, or already proxied URLs
              if (url.startsWith('blob:') || url.startsWith('data:') || 
                  url.includes('api.allorigins.win') || url.includes('cors-anywhere.herokuapp.com') || 
                  url.includes('api.codetabs.com')) {
                return url;
              }
              
              try {
                const absoluteUrl = new URL(url, window.PROXY_BASE_URL).href;
                return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(absoluteUrl);
              } catch (e) {
                return url;
              }
            }
            
            // Game-friendly fetch override with proper relative URL handling
            const originalFetch = window.fetch;
            window.fetch = function(input, init) {
              let url = input;
              if (input instanceof Request) {
                url = input.url;
              }
              
              if (typeof url === 'string') {
                // Handle relative URLs by resolving against base
                if (!url.startsWith('http') && !url.startsWith('data:') && !url.startsWith('blob:')) {
                  url = new URL(url, window.PROXY_BASE_URL).href;
                }
                
                // Proxy external URLs
                if (url.startsWith('http') || url.startsWith('//')) {
                  const proxyUrl = getProxiedUrl(url);
                  if (input instanceof Request) {
                    return originalFetch(new Request(proxyUrl, input), init);
                  }
                  return originalFetch(proxyUrl, init);
                }
              }
              return originalFetch(input, init);
            };

            // Enhanced XMLHttpRequest override with relative URL support
            const originalXHROpen = XMLHttpRequest.prototype.open;
            XMLHttpRequest.prototype.open = function(method, url, ...args) {
              if (typeof url === 'string') {
                // Handle relative URLs
                if (!url.startsWith('http') && !url.startsWith('data:') && !url.startsWith('blob:')) {
                  url = new URL(url, window.PROXY_BASE_URL).href;
                }
                
                if (url.startsWith('http') || url.startsWith('//')) {
                  url = getProxiedUrl(url);
                }
              }
              return originalXHROpen.call(this, method, url, ...args);
            };

            // Game-specific optimizations
            
            // Preserve localStorage and sessionStorage for game saves
            // (These work automatically in the sandbox)
            
            // Comprehensive dynamic asset loading interception for games
            
            // Override property setters for various elements
            ['HTMLImageElement', 'HTMLScriptElement', 'HTMLLinkElement', 'HTMLAudioElement', 'HTMLVideoElement'].forEach(elementType => {
              if (window[elementType]) {
                const srcDescriptor = Object.getOwnPropertyDescriptor(window[elementType].prototype, 'src');
                const hrefDescriptor = Object.getOwnPropertyDescriptor(window[elementType].prototype, 'href');
                
                if (srcDescriptor && srcDescriptor.set) {
                  Object.defineProperty(window[elementType].prototype, 'src', {
                    get: srcDescriptor.get,
                    set: function(value) {
                      if (typeof value === 'string' && !value.startsWith('data:') && !value.startsWith('blob:')) {
                        if (!value.startsWith('http')) {
                          value = new URL(value, window.PROXY_BASE_URL).href;
                        }
                        if (value.startsWith('http')) {
                          value = getProxiedUrl(value);
                        }
                      }
                      srcDescriptor.set.call(this, value);
                    }
                  });
                }
                
                if (hrefDescriptor && hrefDescriptor.set) {
                  Object.defineProperty(window[elementType].prototype, 'href', {
                    get: hrefDescriptor.get,
                    set: function(value) {
                      if (typeof value === 'string' && !value.startsWith('data:') && !value.startsWith('blob:')) {
                        if (!value.startsWith('http')) {
                          value = new URL(value, window.PROXY_BASE_URL).href;
                        }
                        if (value.startsWith('http')) {
                          value = getProxiedUrl(value);
                        }
                      }
                      hrefDescriptor.set.call(this, value);
                    }
                  });
                }
              }
            });
            
            // Enhanced setAttribute override
            const originalSetAttribute = Element.prototype.setAttribute;
            Element.prototype.setAttribute = function(name, value) {
              if ((name === 'src' || name === 'href') && typeof value === 'string' && !value.startsWith('data:') && !value.startsWith('blob:')) {
                if (!value.startsWith('http')) {
                  value = new URL(value, window.PROXY_BASE_URL).href;
                }
                if (value.startsWith('http')) {
                  value = getProxiedUrl(value);
                }
              }
              return originalSetAttribute.call(this, name, value);
            };

            // Handle form submissions with POST support
            document.querySelectorAll('form').forEach(form => {
              form.addEventListener('submit', (e) => {
                e.preventDefault();
                const formData = new FormData(form);
                const action = new URL(form.action || window.location.href, window.PROXY_BASE_URL);
                
                if (form.method.toLowerCase() === 'get') {
                  const params = new URLSearchParams(formData);
                  const newUrl = action.href + (action.href.includes('?') ? '&' : '?') + params.toString();
                  window.parent.postMessage({ type: 'navigate', url: newUrl }, '*');
                } else {
                  // POST forms - notify parent with form data
                  window.parent.postMessage({ 
                    type: 'form_submit', 
                    url: action.href, 
                    method: form.method,
                    formData: Object.fromEntries(formData)
                  }, '*');
                }
              });
            });
            
            // Handle link clicks
            document.addEventListener('click', (e) => {
              let target = e.target;
              while (target && target.tagName !== 'A') {
                target = target.parentElement;
              }
              if (target && target.href && !target.href.startsWith('javascript:')) {
                e.preventDefault();
                const actualUrl = target.getAttribute('data-original-href') || new URL(target.href, window.PROXY_BASE_URL).href;
                window.parent.postMessage({ type: 'navigate', url: actualUrl }, '*');
              }
            });

            // Handle window.open and location changes
            const originalWindowOpen = window.open;
            window.open = function(url, ...args) {
              if (url && typeof url === 'string') {
                const resolvedUrl = new URL(url, window.PROXY_BASE_URL).href;
                window.parent.postMessage({ type: 'navigate', url: resolvedUrl }, '*');
                return null;
              }
              return originalWindowOpen.call(this, url, ...args);
            };

            // Handle meta refresh
            const metaRefresh = document.querySelector('meta[http-equiv="refresh"]');
            if (metaRefresh) {
              const content = metaRefresh.getAttribute('content');
              const match = content.match(/\\d+;\\s*url=(.+)/i);
              if (match) {
                const refreshUrl = new URL(match[1], window.PROXY_BASE_URL).href;
                setTimeout(() => {
                  window.parent.postMessage({ type: 'navigate', url: refreshUrl }, '*');
                }, parseInt(content) * 1000);
              }
            }
          `;
          doc.body.appendChild(newScript);

          iframe.srcdoc = doc.documentElement.outerHTML;

          iframe.onload = () => {
            tab.iframeContainer.classList.remove('loading');
            loadingIndicator.style.display = 'none';
            updateTabTitle(tab, iframe.contentDocument?.title || originalUrl);
            hideOverlay();
          };

          iframe.onerror = () => {
            displayError(tab, 'Failed to load content into iframe.');
            hideOverlay();
          };

        } catch (error) {
          console.error('Fetch error:', error);
          displayError(tab, 'Failed to fetch content through proxy services.');
          hideOverlay();
        }
      }

      // Comprehensive recursive URL rewriting function
      async function rewriteUrls(doc, baseUrl) {
        const base = new URL(baseUrl);

        // Function to get proxied URL using centralized proxy manager
        const getProxiedUrl = (url) => {
          if (proxyManager.isAlreadyProxied(url)) {
            return url; // Don't double-proxy
          }
          return proxyManager.getProxiedUrl(url, baseUrl);
        };

        // Function to rewrite a single attribute
        const rewriteAttribute = (element, attr) => {
          const originalUrl = element.getAttribute(attr);
          if (originalUrl && !originalUrl.startsWith('data:') && !originalUrl.startsWith('#') && !originalUrl.startsWith('javascript:') && !originalUrl.startsWith('mailto:')) {
            try {
              const absoluteUrl = new URL(originalUrl, base).href;
              // Store original URL for link handling
              if (element.tagName === 'A') {
                element.setAttribute('data-original-href', absoluteUrl);
              }
              element.setAttribute(attr, getProxiedUrl(originalUrl));
            } catch (e) {
              console.warn(`Could not rewrite URL for ${element.tagName} with attribute ${attr}: ${e}`);
            }
          }
        };

        // Rewrite all common URL attributes
        doc.querySelectorAll('[src]').forEach(el => rewriteAttribute(el, 'src'));
        doc.querySelectorAll('[href]').forEach(el => rewriteAttribute(el, 'href'));
        doc.querySelectorAll('[action]').forEach(el => rewriteAttribute(el, 'action'));
        doc.querySelectorAll('[poster]').forEach(el => rewriteAttribute(el, 'poster'));
        doc.querySelectorAll('[data]').forEach(el => rewriteAttribute(el, 'data'));

        // Handle srcset attributes
        doc.querySelectorAll('[srcset]').forEach(el => {
          const newSrcset = el.srcset.split(',').map(part => {
            const [url, size] = part.trim().split(/\s+/);
            if (url && !url.startsWith('data:')) {
              try {
                const absoluteUrl = new URL(url, base).href;
                return `${getProxiedUrl(url)} ${size || ''}`.trim();
              } catch (e) {
                console.warn(`Could not rewrite URL in srcset: ${e}`);
                return part;
              }
            }
            return part;
          }).join(', ');
          el.srcset = newSrcset;
        });

        // Handle background images in CSS
        const rewriteCssUrls = (cssText, baseUrl) => {
          return cssText.replace(/url\s*\(\s*['"]?([^'")]+)['"]?\s*\)/gi, (match, url) => {
            if (url.startsWith('data:') || url.startsWith('#')) {
              return match;
            }
            try {
              const absoluteUrl = new URL(url, baseUrl).href;
              return `url("${getProxiedUrl(url)}")`;
            } catch (e) {
              console.warn(`Could not rewrite CSS URL: ${url}`, e);
              return match;
            }
          }).replace(/@import\s+['"]([^'"]+)['"]/gi, (match, url) => {
            if (url.startsWith('data:') || url.startsWith('#')) {
              return match;
            }
            try {
              return `@import "${getProxiedUrl(url)}"`;
            } catch (e) {
              console.warn(`Could not rewrite CSS import: ${url}`, e);
              return match;
            }
          });
        };

        // Rewrite CSS inline styles
        doc.querySelectorAll('[style]').forEach(el => {
          const style = el.getAttribute('style');
          if (style) {
            const rewrittenStyle = rewriteCssUrls(style, base);
            el.setAttribute('style', rewrittenStyle);
          }
        });

        // Rewrite CSS in style tags
        doc.querySelectorAll('style').forEach(async (styleEl) => {
          const cssContent = styleEl.textContent;
          if (cssContent) {
            const rewrittenCss = rewriteCssUrls(cssContent, base);
            styleEl.textContent = rewrittenCss;
          }
        });

        // Process external stylesheets recursively
        const linkElements = doc.querySelectorAll('link[rel="stylesheet"]');
        for (const linkEl of linkElements) {
          const href = linkEl.getAttribute('href');
          if (href && !href.startsWith('data:')) {
            try {
              const cssUrl = new URL(href, base).href;
              
              // Fetch CSS through proxy
              const response = await proxyManager.fetchThroughProxy(cssUrl);
              const cssContent = await response.text();
              
              // Recursively rewrite URLs in CSS content
              const rewrittenCss = rewriteCssUrls(cssContent, new URL(cssUrl));
              
              // Replace link with inline style to avoid double-proxying
              const styleEl = doc.createElement('style');
              styleEl.textContent = rewrittenCss;
              styleEl.setAttribute('data-original-href', cssUrl);
              linkEl.parentNode.replaceChild(styleEl, linkEl);
              
            } catch (error) {
              console.warn(`Failed to fetch and process CSS: ${href}`, error);
              // Leave original link element as fallback
            }
          }
        };

        // Rewrite URLs in script tags (for dynamic content)
        doc.querySelectorAll('script').forEach(scriptEl => {
          const scriptContent = scriptEl.textContent;
          if (scriptContent) {
            // Basic URL rewriting in JavaScript strings (limited)
            const rewrittenScript = scriptContent.replace(
              /(["'])(https?:\/\/[^"']+)\1/g,
              (match, quote, url) => {
                try {
                  return quote + getProxiedUrl(url) + quote;
                } catch (e) {
                  return match;
                }
              }
            );
            scriptEl.textContent = rewrittenScript;
          }
        });

        // Handle meta tags with URLs
        doc.querySelectorAll('meta[content]').forEach(meta => {
          const content = meta.getAttribute('content');
          const property = meta.getAttribute('property') || meta.getAttribute('name');
          
          if (property && (property.includes('image') || property.includes('url')) && content && content.startsWith('http')) {
            try {
              meta.setAttribute('content', getProxiedUrl(content));
            } catch (e) {
              console.warn(`Could not rewrite meta content URL: ${e}`);
            }
          }
        });
      }

      // Function to normalize user input into a valid URL
      function normalizeUrl(input) {
        if (!input) return null;
        try {
          const url = new URL(input.startsWith('http') ? input : `https://${input}`);
          return url.href;
        } catch (e) {
          return `https://www.google.com/search?q=${encodeURIComponent(input)}`;
        }
      }

      // Update the title of a tab
      function updateTabTitle(tab, title) {
        tab.tabElement.querySelector('.tab-title').textContent = title;
      }

      // Update the enabled/disabled state of navigation buttons
      function updateNavigationButtons() {
        if (activeTabIndex === -1 || !tabs[activeTabIndex]) {
          backButton.disabled = true;
          forwardButton.disabled = true;
          return;
        }
        const tab = tabs[activeTabIndex];
        const currentIndex = tab.history.indexOf(tab.url);
        backButton.disabled = currentIndex <= 0;
        forwardButton.disabled = currentIndex >= tab.history.length - 1;
      }

      // Display an error message within the iframe
      function displayError(tab, message) {
        const iframe = tab.iframeContainer.querySelector('iframe');
        iframe.srcdoc = `
          <body style="background: var(--bg-primary); color: var(--error-color); text-align: center; padding-top: 50px;">
            <h1>Error</h1>
            <p>${message}</p>
          </body>
        `;
        tab.iframeContainer.classList.remove('loading');
        loadingIndicator.style.display = 'none';
        updateTabTitle(tab, 'Error');
      }

      // Show the main overlay
      function showOverlay() {
        if (iframeOverlay) {
          iframeOverlay.style.display = 'flex';
        }
      }

      // Hide the main overlay
      function hideOverlay() {
        if (iframeOverlay) {
          iframeOverlay.style.display = 'none';
        }
      }
      
      // Handle messages from iframes to navigate and form submissions
      window.addEventListener('message', (event) => {
        if (activeTabIndex === -1) return;
        
        if (event.data.type === 'navigate') {
          loadUrlInTab(tabs[activeTabIndex], event.data.url);
        } else if (event.data.type === 'form_submit') {
          // Handle POST form submissions (limited support)
          console.warn('POST form submission detected:', event.data);
          displayError(tabs[activeTabIndex], `POST forms are not fully supported. Form action: ${event.data.url}`);
        }
      }, false);

      // Event Listeners
      proxyForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const url = targetUrlInput.value;
        if (activeTabIndex !== -1 && tabs[activeTabIndex]) {
          loadUrlInTab(tabs[activeTabIndex], url);
        } else {
          addTab(url);
        }
      });

      newTabButton.addEventListener('click', () => addTab());

      backButton.addEventListener('click', () => {
        if (activeTabIndex === -1 || !tabs[activeTabIndex]) return;
        const tab = tabs[activeTabIndex];
        const currentIndex = tab.history.indexOf(tab.url);
        if (currentIndex > 0) {
          const prevUrl = tab.history[currentIndex - 1];
          loadUrlInTab(tab, prevUrl);
        }
      });

      forwardButton.addEventListener('click', () => {
        if (activeTabIndex === -1 || !tabs[activeTabIndex]) return;
        const tab = tabs[activeTabIndex];
        const currentIndex = tab.history.indexOf(tab.url);
        if (currentIndex < tab.history.length - 1) {
          const nextUrl = tab.history[currentIndex + 1];
          loadUrlInTab(tab, nextUrl);
        }
      });

      // Initial state
      if (tabs.length === 0) {
        addTab();
      }
    });
  </script>
</body>
</html>
